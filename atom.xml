<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Huskyyy&#39;s backyard</title>
  <subtitle>Now or Never.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2016-04-24T14:01:15.769Z</updated>
  <id>/</id>
  
  <author>
    <name>Huskyyy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RecycleView之自定义LayoutManager(上)</title>
    <link href="/2016/04/18/RecycleView-Post-1/"/>
    <id>/2016/04/18/RecycleView-Post-1/</id>
    <published>2016-04-18T12:16:03.000Z</published>
    <updated>2016-04-24T14:01:15.769Z</updated>
    
    <content type="html">&lt;p&gt;　　很早的时候看到了这么一个&lt;a href=&quot;https://github.com/dodola/DynamicCardLayout&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;类似win8的瓷片式布局&lt;/a&gt;。而后又学习了RecycleView的使用。心想就用RecycleView实现这个布局吧。最后成品&lt;a href=&quot;https://github.com/Huskyyy/IrregularGridView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在此&lt;/a&gt;。先贴上效果图。&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;float:left;&quot; src=&quot;https://raw.githubusercontent.com/Huskyyy/IrregularGridView/master/gif/Base.gif&quot;&gt;  &lt;img style=&quot;float:center;&quot; src=&quot;https://raw.githubusercontent.com/Huskyyy/IrregularGridView/master/gif/Gallery.gif&quot;&gt; &lt;/p&gt;
&lt;p&gt;　　和&lt;a href=&quot;https://github.com/dodola/DynamicCardLayout&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考的那个布局&lt;/a&gt;相比，用RecycleView实现的布局能够实现View的回收，同时还支持RecycleView默认的移除动画效果。之后尝试写修改view的宽度的动画，未果。于是最终的移除动画变成了上面的缩放加移动，这一块留到之后再说。&lt;/p&gt;
&lt;p&gt;　　如果你英语阅读能力良好，可以直接移步&lt;a href=&quot;http://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。接下来的内容基本上都包含在前面链接的博客里，加上了我个人的一些理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本概念的介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　1. Recycler&lt;/p&gt;
&lt;p&gt;　　在RecycleView中，Recycler负责管理子View的创建以及回收利用。在你的LayoutManager中，如果想要获取某一个子View，应调用Recycler的&lt;code&gt;getViewForPosition()&lt;/code&gt;方法来获取，该方法会返回已绑定好数据的View对象。Recycler会根据具体情况来决定是否创建一个子View，或是将某个已回收的子View再利用。那什么时候会创建一个子View，什么时候又会将已回收的子View再利用呢？这又涉及到被回收的子View的两种状态，scrap和recycle。&lt;/p&gt;
&lt;p&gt;　　2. Scrap &amp;amp; Recycle&lt;/p&gt;
&lt;p&gt;　　Recycler所缓存的子View有两种状态，即scrap状态和recycle状态。当你在一次layout的过程中，想重新组织子View的布局，通常应该先对当前attached的子View调用&lt;code&gt;detachAndScrapView()&lt;/code&gt;来回收子View或者直接调用&lt;code&gt;detachAndScrapAttachedViews()&lt;/code&gt;回收所有attached的子View。Recycler会判断是否将子View缓存到scrap堆中或者是recycle池中。而如果你想将不可见的子View进行回收，则应该调用&lt;code&gt;removeAndRecycleView()&lt;/code&gt;或者类似的方法来将View直接回收到recycle池中。然后，在layout的过程中，当你调用Recycler的&lt;code&gt;getViewForPosition()&lt;/code&gt;来获取某个位置的子View时，Recycler会优先在scrap堆中查找是否有对应位置的子View，找到对应的子View并且满足一定的条件（例如数据没有变化等），则会将其直接返回。否则Recycler会在recycle池中查找可再利用的子View并重新绑定数据（即调用&lt;code&gt;onBindViewHolder()&lt;/code&gt;方法）再将其返回。由此可见，scrap适用于重新布局时子View需要立即被layout出来时使用，而recycle适用于将子View完全回收时使用。实际上Recycler获取子View的过程更为复杂，但原理是类似的。&lt;/p&gt;
&lt;p&gt;　　首先说明一下LayoutManager的作用吧。RecycleView的LayoutManager负责子View的具体布局，以及当用户与RecycleView交互（例如滚动以及对子View进行增删改查等）时，子View的具体变化（包括显示，移动，回收等）。我们先不考虑太多复杂的功能，就想想第一次初始化的时候子View该如何布局吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只考虑初始化时的layout过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　首先，如果要自定义一个LayoutManager，那么必须要实现RecycleView.LayoutManager中的唯一一个抽象方法，即&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract LayoutParams generateDefaultLayoutParams();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　实现的方法可以很简单，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public RecyclerView.LayoutParams generateDefaultLayoutParams() {
    return new LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　而实际上最重要的方法却不是抽象的（这一点就不吐槽了）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void onLayoutChildren(Recycler recycler, State state) {
    Log.e(TAG, &amp;quot;You must override onLayoutChildren(Recycler recycler, State state) &amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　可以说&lt;code&gt;onLayoutChildren()&lt;/code&gt;方法是LayoutManager中最为关键的方法之一吧。&lt;code&gt;onLayoutChildren()&lt;/code&gt;主要负责子View的layout过程。具体而言，在RecycleView初始化的时候，以及当子View发生改变（增删改等）时，都会触发&lt;code&gt;onLayoutChildren()&lt;/code&gt;方法。先考虑初始化时，我们要干什么。&lt;/p&gt;
&lt;p&gt;　　初始化的时候，&lt;code&gt;onLayoutChildren()&lt;/code&gt;需要负责将子View绘制出来。如果你不了解View的绘制流程，可以参考&lt;a href=&quot;http://blog.csdn.net/guolin_blog/article/details/16330267&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。对于每一个子View，大概的绘制流程如下（仅作步骤参考）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, boolean isFillBottom, boolean isForAnimation){

    // Necessary initialization.
    .......
    Rect mDecorInsets = new Rect();

    // Firstly we get view from the recycler.
    View view = recycler.getViewForPosition(mCurrentPosition);

    // Calculate the left, right, top and bottom of the view to be laid out.
    final LayoutParams lp = (LayoutParams) view.getLayoutParams();
    int left = 0, right = 0, top = 0, bottom = 0;
    calculateItemDecorationsForChild(view, mDecorInsets);
    left = getPaddingLeft() + spanWidthBorders[nextItemIndex] + lp.leftMargin;
    right = getPaddingLeft() + spanWidthBorders[nextItemIndex + widthNum] - lp.rightMargin;
    if(isFillBottom){
        top = getPaddingTop() + spanBottomMin + lp.topMargin;
        bottom = getPaddingTop() + spanBottomMin + sizePerSpan * heightNum - lp.bottomMargin;
    }else{
        bottom = getPaddingTop() + spanTop[nextItemIndex] - lp.bottomMargin;
        top = getPaddingTop() + spanTop[nextItemIndex] - sizePerSpan * heightNum + lp.topMargin;
    }

    // If we lay out the view to fill bottom, add the view to the end.
    if(isFillBottom) {
        addView(view);
    }else if(!isFillBottom){ // Otherwise it is added to the beginning.
        addView(view, 0);
    }

    // Make measureSpec.
    int widthSpec, heightSpec;
    widthSpec = View.MeasureSpec.makeMeasureSpec(
            right - left - mDecorInsets.left - mDecorInsets.right, View.MeasureSpec.EXACTLY);
    heightSpec = View.MeasureSpec.makeMeasureSpec(
            bottom - top - mDecorInsets.top - mDecorInsets.bottom, View.MeasureSpec.EXACTLY);

    // Measure child and layout.
    view.measure(widthSpec, heightSpec);
    layoutDecorated(view, left, top, right, bottom);

    // update some parameters
    ......
}    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　首先，我们通过&lt;code&gt;recycler.getViewForPosition()&lt;/code&gt;方法获取当前要绘制出来的子View。接下来我们需要计算出该子View被绘制出来的具体位置。该位置分别由子View的左右上下边界来确定。这部分的逻辑跟你的RecycleView的具体类型有关。例如对于ListView类型的RecycleView，其左右边界就是RecycleView的左右边界，上下边界则由当前子View的位置来计算出来。当然实际上还要考虑RecycleView的padding设置以及子View的margin，decoration的尺寸。注意这里的边界的计算是相对于RecycleView而言的。&lt;/p&gt;
&lt;p&gt;　　接下来调用&lt;code&gt;addView()&lt;/code&gt;将该子View添加到当前的RecycleView中。注意&lt;code&gt;addView()&lt;/code&gt;方法可以带第二个参数，其第二个参数决定了当前添加到RecycleView中的子View的index。这里还要解释一下position和index的区别。在写LayoutManager的过程中，会看到带有position和index的不同方法，通常position对应的是该子View在Adapter中的真实位置，而index对应了该子View在RecycleView所保存的所有子View里的相对位置。&lt;/p&gt;
&lt;p&gt;　　确定了子View的layout的具体位置后，接下来就是正常的View的绘制流程了。先调用View的&lt;code&gt;measure()&lt;/code&gt;或者类似的方法测量子View的大小，当然是要考虑子View的margin，decoration参数。然后调用&lt;code&gt;layoutDecorated()&lt;/code&gt;方法将子View布局出来。具体的&lt;code&gt;onDraw()&lt;/code&gt;方法则由子View自己实现，并不需要我们处理。&lt;/p&gt;
&lt;p&gt;　　经过这么一番折腾，一个子View就能够绘制出来了。实际上我们需要绘制很多个子View，所以需要在结束的时候更新一些和布局相关的参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑视图的滚动逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　RecycleView，顾名思义，当然是能够将不必要的View及时回收再利用，减少占用的内存。当我们处理完初始化流程后，自然需要支持RecycleView的滚动逻辑以及子View的及时回收。如果要支持竖直方向上的滚动，那么我们需要覆盖这个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public boolean canScrollVertically(){
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　如果要支持水平方向上的滚动，则需要覆盖&lt;code&gt;canScrollHorizontally()&lt;/code&gt;方法。假设我们支持竖直方向上的滚动，那么当用户在RecycleView内滑动时，就会触发&lt;code&gt;scrollVerticallyBy()&lt;/code&gt;方法。因此我们需要覆盖这个方法，实现子View的滚动和回收。实现的方法因人而异，这里给出一种参考方法。该方法的大致流程如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state){

    int delta = 0;
    // Scroll down, update bottomBorder and fill.
    if(dy &amp;gt; 0){
        // Necessary initialization and the calculation of the space needed be filled.
        .......
        // Fill the space.
        fillGrid(recycler, state, true);
        // Update delta, note that delta is the actual offset we can achieve.
        if(spanBottomMin &amp;gt;= bottomBorder) {
            delta = dy;
            bottomBorder -= dy;
        }else { // There are no more items we need to lay out.
            bottomBorder = getHeight() - getPaddingBottom();
            if(spanBottomMax - bottomBorder &amp;gt;= dy){
                delta = dy;
            }else{
                delta = Math.max(0, spanBottomMax - bottomBorder);
            }
        }
        // Offset child views.
        offsetChildrenVertical(-delta);
        // After offset children, we need to update parameters.
        ......
        // Recycle views out of the topBorder
        recycleTopInvisibleViews(recycler);
    }else{ // dy &amp;lt; 0
        ......
    }
    // Update scrollOffset.
    scrollOffset += delta;
    // Return the offset we made.
    return delta;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　其中dy表示滑动的距离。先只考虑用户从下往上滑动的情形，此时整个列表往上滚动，dy&amp;gt;0。需要我们做的事情一共有这么几件。&lt;/p&gt;
&lt;p&gt;　　第一步，计算出我们需要填充的空间，初始化相关的参数。第二步，调用相应的方法（在这里是&lt;code&gt;fillGrid()&lt;/code&gt;）将需要填充的部分填充完，具体的填充过程跟上面的&lt;code&gt;layoutChunk()&lt;/code&gt;过程类似。实际上可能由于没有item需要layout（即滑动到边界了）导致无法将相应的空间填满，因此需要根据实际layout的情况来确定真正填充了多少，并以此来确定子View能够滚动的距离。这就是第三步，确定实际滚动的距离delta。第四，调用&lt;code&gt;offsetChildrenVertical()&lt;/code&gt;将所有子View移动一段距离。最后，将完全移动到屏幕外的子View回收掉。对于dy&amp;gt;0的情况，我这里调用的是&lt;code&gt;recycleTopInvisibleViews(recycler)&lt;/code&gt;方法，即回收掉移动到上边界之外的子View，其内部调用&lt;code&gt;removeAndRecycleView()&lt;/code&gt;来进行子View的回收。当用户从上往下滑动时，对应的处理过程类似，这里就不再重复了。&lt;/p&gt;
&lt;p&gt;　　以上就是自定义LayoutManager中，如何进行第一次layout，以及如何应对滚动逻辑的大致过程。如果你还想考虑子View发生增删改时，LayoutManager的处理，可以继续阅读RecycleView之自定义LayoutManager(下)。&lt;/p&gt;
&lt;p&gt;　　&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;　　很早的时候看到了这么一个&lt;a href=&quot;https://github.com/dodola/DynamicCardLayout&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;类似win8的瓷片式布局&lt;/a&gt;。而后又学习了RecycleView的使用。
    
    </summary>
    
      <category term="自定义View" scheme="/categories/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
    
      <category term="RecycleView" scheme="/tags/RecycleView/"/>
    
      <category term="LayoutManager" scheme="/tags/LayoutManager/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="/2016/04/13/hello-world/"/>
    <id>/2016/04/13/hello-world/</id>
    <published>2016-04-13T13:04:44.695Z</published>
    <updated>2016-04-17T15:55:11.584Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
